"use strict"

# translates vm files into javascript functions corresponding to
# the VM functions. However, the native 
# javascript call stack can't be used because:
#
# 1. getting keyboard input requires the code to be paused at a
# 	certain point, which javascript can't do.
# 
# 2. The stack frame has to be stored in RAM anyway for the hack platform
# 	specific features like Memory.poke and Screen access to work as 
# 	expected. This also means that using native JS Arrays to implement
# 	the different stacks is impossible (e.g. locals.push() instead of
# 	RAM[ RAM[0]++ ] = RAM[ RAM[LCL] ])
#
# This approach is similar to what emscripten does for LLVM->JS,
# but I don't have their fancy Relooping algorithm for converting
# labels back to native javascript control statements, at least not yet.
@translate = !->
	it = [it] unless Array.isArray it # wrap single files in an array
	# translate basic instructions
	arithmetic = add: \+, sub: \-, and: \&, or: \|
	unary = neg: \-, not: \~
	boolean = eq: \===, gt: \>, lt: \<

	push_segment = 
		constant: -> it
		argument: load_from_base \ARG
		local: load_from_base \LCL
		this: load_from_base \THIS
		that: load_from_base \THAT
		temp: -> load_D 5 + parseInt it, 10
		pointer: -> load_D 3 + parseInt it, 10
	# TODO reading from pointer needs a check
	# to see if pointer is 24576 and if it is
	# generate a label/case and return from it, so
	# we can setTimeout to the other side of the keyboard callback
	pop_segment = 
		argument: addr_from_base \ARG
		local: addr_from_base \LCL
		this: addr_from_base \THIS
		that: addr_from_base \THAT
		temp: -> set_D 5 + parseInt it, 10
		pointer: -> set_D 3 + parseInt it, 10
	
	# initialize and remove all previous functions
	vm.functions = {}

	it.forEach !(input, idx)-> # for each file, with unique index
			# TODO some way to map static variables properly to RAM[16] and up
			# can use idx of file instead of filename, since it's still unique

			# holds name of current function
			current_fn = void
			# all the lines of code for the current function
			code = []

			input # strip comments and whitespace, then split into lines
				.replace /\/\/.*/gm "" .trim! .split /\s*[\n\r]+\s*/
				.forEach (it, i) -> # parse instructions
					if it.match /^push (constant|argument|local|static|this|that|pointer|temp) (\d+)$/
						code.push "RAM[ RAM[0]++ ] = #{push_segment[that.1] that.2}"
					else if it.match /^pop (argument|local|static|this|that|pointer|temp) (\d+)$/
						code.push "RAM[ RAM[ #{ pop_segment[that.1] that.2} ] ] = RAM[ --RAM[0] ]"
					else if it.match /^function ([A-Za-z\._\:][\w_\.\:]+) (\d+)$/
						# flush last function, with text body, and one parameter 'label'
						vm.functions[current_fn] = new Function do
							'label'
							"
							var RAM = vm.RAM;
							#{ # initialize local variables
							(for j til parseInt that.2
								"RAM[ RAM[0]++ ] = 0"
							).join ';'
							};
							loop: for(;;) {
								switch( label ) {
									default: #{ code.join ';'};
								}
							}
							"
						# start new function
						code := [] 
						current_fn := that.1
					else if it.match /^call ([A-Za-z\._\:][\w_\.\:]+) (\d+)$/
						code.push do
							"RAM[ RAM[0]++ ] = RAM[ RAM[ #LCL ] ]"
							"RAM[ RAM[0]++ ] = RAM[ RAM[ #ARG ] ]"
							"RAM[ RAM[0]++ ] = RAM[ RAM[ #THIS ] ]"
							"RAM[ RAM[0]++ ] = RAM[ RAM[ #THAT ] ]"

						lines do
							push_A "#name-return-from-call-#i"
							push_M \LCL
							push_M \ARG
							push_M \THIS
							push_M \THAT
							\@SP
							\D=M
							\@LCL # set LCL to SP
							\M=D 
							\@5 # set ARG to SP-5-args
							\D=D-A
							A that[2] #subtract number of args
							\D=D-A
							\@ARG
							\M=D
							A that[1]
							'A;JMP'
							label "#name-return-from-call-#i"
					else if it is \return
						lines do
							\@LCL
							\D=M-1
							store_D \FRAME # store frame pointer
							\@4
							\A=D-A
							\D=M # D contains *(FRAME-5)
							store_D \RET # return addr stored
							pop_D 
							\@ARG
							\A=M
							\M=D # reposition return value at *ARG
							\@ARG
							\D=M+1
							store_D \SP # restore stack pointer
							pop_frame \THAT
							pop_frame \THIS
							pop_frame \ARG
							pop_frame \LCL
							\@RET # grab return address
							\A=M
							'A;JMP'
					else if it.match /^label ([A-Za-z\._\:][\w_\.\:]+)$/
						code.push "case '#it': "
					else if it.match /^goto ([A-Za-z\._\:][\w_\.\:]+)$/
						# use case statement inside loop to simulate goto in javascript
						# slower, but more easily implemented than trying to reconstruct
						# if and while statements in native javscript from labels
						code.push "label = '#{that.1}'; continue loop"
					else if it.match /^if-goto ([A-Za-z\._\:][\w_\.\:]+)$/
						code.push "if(RAM[0] !== 0) { label = '#it'; continue loop; }"
					# TODO check spec for order of operands
					else if arithmetic[it]
						code.push "RAM[ --RAM[0] ] = RAM[ RAM[0] ] #that RAM[ RAM[0] - 1 ]"
					else if boolean[it]
						code.push "RAM[ --RAM[0] ] = RAM[ RAM[0] - 1 ] #it RAM[ RAM[0] ] ? -1 : 0"
					else if unary[it]
						code.push "RAM[ RAM[0] ] = #{that}RAM[ RAM[0] ]"
					else
						throw new Error """couldn't parse "#it" around line #i in file "#name"!"""

