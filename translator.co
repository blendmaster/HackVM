"use strict"

# translates vm files into javascript functions corresponding to
# the VM functions. However, the native 
# javascript call stack can't be used because:
#
# 1. getting keyboard input requires the code to be paused at a
# 	certain point, which javascript can't do.
# 
# 2. The stack frame has to be stored in RAM anyway for the hack platform
# 	specific features like Memory.poke and Screen access to work as 
# 	expected. This also means that using native JS Arrays to implement
# 	the different stacks is impossible (e.g. locals.push() instead of
# 	RAM[ RAM[0]++ ] = RAM[ RAM[LCL] ])
#
# This approach is similar to what emscripten does for LLVM->JS,
# but I don't have their fancy Relooping algorithm for converting
# labels back to native javascript control statements, at least not yet.
arithmetic = add: \+, sub: \-, and: \&, or: \|
unary = neg: \-, not: \~
boolean = eq: \===, gt: \>, lt: \<

# ram positions of segments
LCL = 1
ARG = 2
THIS = 3
THAT = 4

push_base = (base) -> -> "RAM[ RAM[0]++ ] = RAM[ RAM[ #base ] + #it ]"
push_segment = 
	constant: -> "RAM[ RAM[0]++ ] = #it"
	argument: push_base ARG
	local: push_base LCL
	this: push_base THIS
	# that defined inside loop to close over variables
	temp: -> "RAM[ RAM[0]++ ] = RAM[ #{5 + parseInt it, 10} ]"
	pointer: -> "RAM[ RAM[0]++ ] = RAM[ #{3 + parseInt it, 10} ]"

pop_to_base = (base) -> -> "RAM[ RAM[ #base ] + #it ]"
pop_segment = 
	argument: pop_to_base ARG
	local: pop_to_base LCL
	this: pop_to_base THIS
	that: pop_to_base THAT
	temp: -> "RAM[ #{5 + parseInt it, 10} ]"
	pointer: -> "RAM[ #{3 + parseInt it, 10} ]"

# holds name of current function
# these are defined here, so flush can close over them
current_fn = void
current_fn_locals = void # num arguments 

# all the lines of code for the current function
code = []

# adds boilerplate and pushes a new function object with internal code
# equivalent to VM function
flush = ->
	console.log "defined #current_fn"
	vm.functions[current_fn] = new Function do
		'label'
		"
		var RAM = vm.RAM, frame, addr;
		#{# initialize local variables
		(for j til current_fn_locals
			"RAM[ RAM[0]++ ] = 0"
		).join ';'
		};
		loop: for(;;) {
			switch( label ) {
				case 0: #{code.join ';'};
			}
		}"
	# add name attribute to function for debugging
	vm.functions[current_fn].fn_name = current_fn

@translate = !->
	it = [it] unless Array.isArray it # wrap single files in an array
	
	# initialize and remove all previous functions
	vm.functions = {}

	# keep track of all the static variables used across the files
	static_addr = 16
	statics = {}

	it.forEach !(input, idx)-> # for each file, with unique index
		# start fresh
		current_fn := void
		current_fn_locals := void # num arguments 

		# all the lines of code for the current function
		code := []

		# possible firefox bug, evaluates javascript:
		# switch(label) {
		# 	default: alert('hi');
		# }
		#
		# to an empty switch statement, i.e. if there are no case statements
		# in the switch, firefox leaves it blank. lame as hell
		# thus, we start at label 1, leaving label 0 for the beginning
		#
		# used to number each of the labels generated in the function
		label = 1
		labels = {} # hash of label name to number

		# this is defined here to take close over labels, so we can set
		# a label for keyboard returns
		push_segment.that = ->
			# assuming only the 'that' pointer will be used to access keyboard and
			# memory, so we can detect those and do the dirty work
			# map_screen recieves the top address of the stack to convert into canvas
			# pixels, while keyboard access pauses execution
			"addr = RAM[ #THAT ] + #it;
			if( addr == 24576 ) {
				vm.io = true;
				vm.label = #label;
				return;
			}
			if( addr >= 16384 ) { vm.map_screen( addr, RAM[ RAM[0] - 1 ] ); }
			case #{label++}: 
				RAM[ RAM[0]++ ] = RAM[ RAM[ #THAT ] + #it ]"

		# these are closed over the current file
		push_segment.static = -> "RAM[ RAM[0]++ ] = RAM[ #{statics["#idx.#it"] ?= static_addr++} ]"
		pop_segment.static = -> "RAM[ #{statics["#idx.#it"] ?= static_addr++} ]"

		input # strip comments and whitespace, then split into lines
			.replace /\/\/.*/gm "" .trim! .split /\s*[\n\r]+\s*/
			.forEach !(it, i) -> # parse instructions
				if it.match /^push (constant|argument|local|static|this|that|pointer|temp) (\d+)$/
					code.push push_segment[that.1] that.2
				else if it.match /^pop (argument|local|static|this|that|pointer|temp) (\d+)$/
					code.push "#{pop_segment[that.1] that.2} = RAM[ --RAM[0] ]"
				else if match = it.match /^function ([A-Za-z\._\:][\w_\.\:]+) (\d+)$/
					if current_fn
						flush! # add to vm.functions
						# start new function
						code := [] 
						current_fn := match.1
						current_fn_locals = parseInt match.2, 10
						label := 1
						labels := {}
					else # set current fn only, for first function definition
						current_fn := match.1
						current_fn_locals = parseInt match.2, 10
				else if it.match /^call ([A-Za-z\._\:][\w_\.\:]+) (\d+)$/
					code.push do
						"RAM[ RAM[0]++ ] = #{label}" # pushing return address as label addr
						"RAM[ RAM[0]++ ] = RAM[ RAM[ #LCL ] ]"
						"RAM[ RAM[0]++ ] = RAM[ RAM[ #ARG ] ]"
						"RAM[ RAM[0]++ ] = RAM[ RAM[ #THIS ] ]"
						"RAM[ RAM[0]++ ] = RAM[ RAM[ #THAT ] ]"
						"RAM[ #ARG ] = RAM[0] - #{parseInt(that.2, 10) + 5}" # num of locals + stack frame
						"RAM[ #LCL ] = RAM[0]"
						"console.log('calling #{that.1} from #{current_fn}')"
						"vm.callstack.push( vm.functions['#{that.1}'] )"
						"vm.label = 0" # set starting address for called function to beginning (default)
						"return" # give control to top of callstack
						"case #{label++}: " # returned from function
				else if it is \return
					code.push do
						"frame = RAM[ #LCL ]"
						"vm.label = RAM[ frame - 5 ]" # set "return address"
						"RAM[ RAM[ #ARG ] ] = RAM[ RAM[0]-- ]"
						"RAM[0] = RAM[ #ARG ] + 1"
						"RAM[ #THAT ] = RAM[ frame - 1 ]"
						"RAM[ #THIS ] = RAM[ frame - 2 ]"
						"RAM[ #ARG ] = RAM[ frame - 3 ]"
						"RAM[ #LCL ] = RAM[ frame - 4]"
						"vm.callstack.pop()" # pop this function off callstack
						"return"
				else if it.match /^label ([A-Za-z\._\:][\w_\.\:]+)$/
					code.push "case #{labels[that.1] ?= label++ }: "
				else if it.match /^goto ([A-Za-z\._\:][\w_\.\:]+)$/
					code.push "label = #{labels[that.1] ?= label++ }; continue loop"
				else if it.match /^if-goto ([A-Za-z\._\:][\w_\.\:]+)$/
					code.push "if(RAM[ RAM[0]-- ] !== 0) { label = #{labels[that.1] ?= label++ }; continue loop; }"
				else if arithmetic[it]
					code.push "RAM[ --RAM[0] ] = RAM[ RAM[0] - 1 ] #that RAM[ RAM[0] ]"
				else if boolean[it]
					code.push "RAM[ --RAM[0] ] = RAM[ RAM[0] - 1 ] #that RAM[ RAM[0] ] ? -1 : 0"
				else if unary[it]
					code.push "RAM[ RAM[0] - 1 ] = #{that}RAM[ RAM[0] - 1 ]"
				else
					throw new Error """couldn't parse "#it" around line #i in file "#name"!"""
		# flush last function
		console.log "flush last function"
		flush! # add to vm.functions

